export default class Shaders {

    constructor(gui) {
        this.dataAttributes = []; // Preprocessed information generated from the data set
        this.customUniforms = []; // Preprocessed information generated from the data set
        this.customAttributes = []; // Preprocessed information generated from the data set
 
    }

    // Gets the index of a data attribute based on its name (reverse index)
    getDataAttributeIndex(setId, name) {
        for (let i = 0; i < this.dataAttributes.length; i++) {
            if (
                this.dataAttributes[i].name == name &&
                this.dataAttributes[i].dataset == setId
            ) {
                return i;
            }
        }
        return -1;
    }

    getAttributesOfSet(setId) {
        let attributes = []
        for (let a = 0; a < this.dataAttributes.length; a++) {
            if (this.dataAttributes[a].dataset === setId) {
                attributes.push(this.dataAttributes[a])
            }
        }
        return attributes;
    }

    updateDataAttributeMinMax(id, value) {
        this.dataAttributes[id].min = Math.min(
            this.dataAttributes[id].min,
            value);
        this.dataAttributes[id].max = Math.max(
            this.dataAttributes[id].max,
            value);
    }

    // Adds preliminary notes for a new data attribute to the list of attributes.
    // (Data attribute means: something directly copied from the given data, like position.)
    addDataAttribute(dataset, name, dim, min, max, shared, fixedColor) {
        for (let i = 0; i < this.dataAttributes.length; i++) {
            if (
                this.dataAttributes[i].name == name &&
                this.dataAttributes[i].dataset == dataset
            ) {
                console.error(
                    "This attribute exists twice:",
                    name,
                    "of dataset",
                    dataset
                );

                return;
            }
        }
        let i = this.dataAttributes.length;
        let type = "float";
        if (dim == 2) {
            type = "vec2";
        } else if (dim == 3) {
            type = "vec3";
        }

        this.dataAttributes.push({});
        this.dataAttributes[i].type = type;
        this.dataAttributes[i].dataset = dataset;
        this.dataAttributes[i].dim = dim;
        this.dataAttributes[i].name = name;
        this.dataAttributes[i].shared = shared;
        this.dataAttributes[i].fixedColor = fixedColor;
        this.dataAttributes[i].min = min;
        this.dataAttributes[i].max = max;
    }

    
    // Adds notes for a custom attribute to the list of attributes.
    // (Custom attribute means: something like meta data that is generated by this viewer. Let's call it "metadata".)
    addCustomAttribute(
        dataset,
        type,
        name,
        dependency,
        count,
        interpolate,
        normalize,
        shared
    ) {
        let i = this.customAttributes.length;
        for (let j = 0; j < i; j++) {
            if (
                this.customAttributes[j]["name"] == name &&
                this.customAttributes[j]["dataset"] == dataset
            ) {
                return; // Don't add twice
            }
        }
        this.customAttributes.push({});
        this.customAttributes[i].type = type;
        this.customAttributes[i].dataset = dataset;
        this.customAttributes[i].dependency = dependency;
        this.customAttributes[i].count = count;
        this.customAttributes[i].name = name;
        this.customAttributes[i].interpolate = interpolate;
        this.customAttributes[i].normalize = normalize;
        this.customAttributes[i].shared = shared;
    }

    

    // Adds preliminary notes for uniforms we want later to create inside the shader source code
    addCustomUniform(dataset, type, name, num, value) {
        for (let i = 0; i < this.customUniforms.length; i++) {
            if (
                this.customUniforms[i].name === name &&
                this.customUniforms[i].dataset === dataset
            ) {
                return;
            }
        }
        let newUniform = {};
        newUniform.dataset = dataset;
        newUniform.type = type;
        newUniform.name = name;
        newUniform.num = num;
        newUniform.value = value;
        this.customUniforms.push(newUniform);
    }


    addCustomAttributesToShader(setId, shader) {
        return this.addCustomAttributesToShaderStep(
            setId,
            false,
            this.addCustomAttributesToShaderStep(setId, true, shader)
        );
    }

    // Alters the shader source: interpolate state-specific attributes
    addCustomAttributesToShaderStep(setId, defineTypes, shader) {
        console.log("Call addCustomAttributesToShader for dataset ", setId);
        let newCode = "\n";
        let newCodeInterp = "\n";
        for (let i = 0; i < this.customAttributes.length; i++) {
            if (this.customAttributes[i].dataset !== setId) continue;
            console.log(
                "Handle attribute ",
                i,
                ", ",
                this.customAttributes[i].name
            );
            let name = this.cleanVarName(this.customAttributes[i].name);
            newCodeInterp += this.createAttributeForShader(
                name,
                this.customAttributes[i].type,
                this.customAttributes[i].dependency,
                this.customAttributes[i].count,
                this.customAttributes[i].shared,
                this.customAttributes[i].interpolate,
                this.customAttributes[i].normalize,
                true,
                4,
                defineTypes
            );

            if (this.customAttributes[i].shared) {
                newCode +=
                    "attribute " +
                    this.customAttributes[i].type +
                    " " +
                    name +
                    ";\n";
            } else {
                for (let j = 0; j < this.customAttributes[i].count; j++) {
                    newCode +=
                        "attribute " +
                        this.customAttributes[i].type +
                        " " +
                        name +
                        j +
                        ";\n";
                }
            }
        }

        shader = shader.replace(
            "#genericAttributeInterpolation#",
            newCodeInterp
        );
        shader = shader.replace("#genericAttributes#", newCode);
        return shader;
    }


    // Capitalizes only first word of a string
    capitalizeFirst(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    }
    

    // Creates a nice name applicable as variable name for shader code
    cleanVarName(name) {
        // There should be more rules, I guess...
        let nameCleaned = name.replace(/[^A-Za-z0-9]/g, "");

        if (nameCleaned.match(/^\d/)) {
            let m =
                "Error! Attribute " +
                name +
                " must start with a non-numeric character.";
            alert(m);
            throw new Error(m);
        }
        return nameCleaned;
    }

    // Alters the shader source: add a color mode for each attribute (e.g. colorize according to time point).
    addColorModesToShader(setId, shader) {
        let nl = "\n" + Array(5).join(" ");
        let code = nl;
        let magicNumber = 7; // Assuming we already have n color modes, so we add a (n+1)th one here
        let attributes = this.getAttributesOfSet(setId);
        for (let i = 0; i < attributes.length; i++) {
            let attribute = attributes[i];
            let name = this.cleanVarName(attribute.name);
            let lower = attribute.fixedColor
                ? name + "Min"
                : "max(" + name + "Min, " + name + "From)";
            let upper = attribute.fixedColor
                ? name + "Max"
                : "min(" + name + "To," + name + "Max)";
            code +=
                "else if(colorMode == " +
                (magicNumber + i) +
                ") {float t = (v" +
                this.capitalizeFirst(name) +
                " - " +
                lower +
                ") / (" +
                upper +
                " - " +
                lower +
                "); gl_FragColor.xyz = getColor(t, 1.).xyz;}" +
                nl;
        }
        shader = shader.replace("#colorModes#", code);
        return shader;
    }

     // Alters the shader source: add a opacity mode for each attribute (e.g. opacity according to time point).
     addOpacityModesToShader(setId, shader) {
        let nl = "\n" + Array(5).join(" ");
        let code = nl;
        let magicNumber = 1; // Assuming we already have n opacity modes, so we add a (n+1)th one here
        let attributes = this.getAttributesOfSet(setId);
        for (let i = 0; i < attributes.length; i++) {
            let attribute = attributes[i];
            let name = this.cleanVarName(attribute.name);
            let lower = attribute.fixedColor
                ? name + "Min"
                : "max(" + name + "Min, " + name + "From)";
            let upper = attribute.fixedColor
                ? name + "Max"
                : "min(" + name + "To," + name + "Max)";
            code +=
                "else if(opacityMode == " +
                (magicNumber + i) +
                ") {alphaScale = (v" +
                this.capitalizeFirst(name) +
                " - " +
                lower +
                ") / (" +
                upper +
                " - " +
                lower +
                ");}" +
                nl;
        }
        shader = shader.replace("#adjustAlpha#", code);
        return shader;
    }

    // Alters the shader source: add mercator height for each attribute (e.g. late time points -> higher peaks in mercator)
    addMercatorModesToShader(setId, shader) {
        let nl = "\n" + Array(5).join(" ");
        let code = nl;
        code += "if(false) {} " + nl; // Dummy - maybe something else?
        let magicNumber = 0; // Assuming we already have 0 mercator modes
        let attributes = this.getAttributesOfSet(setId);
        for (let i = 0; i < attributes.length; i++) {
            let attribute = attributes[i];

            let name = this.cleanVarName(attribute.name);
            let lower = attribute.fixedColor
                ? name + "Min"
                : "max(" + name + "Min, " + name + "From)";
            let upper = attribute.fixedColor
                ? name + "Max"
                : "min(" + name + "To," + name + "Max)";
            code +=
                "else if(mercatorMode == " +
                (magicNumber + i) +
                ") {mercatorHeight = (v" +
                this.capitalizeFirst(name) +
                " - " +
                lower +
                ") / (" +
                upper +
                " - " +
                lower +
                ");}" +
                nl;
        }
        shader = shader.replace("#mercatorModes#", code);
        return shader;
    }

    
    // Alters the shader source: varying for each vertex attribute
    addVaryingsToShader(setId, shader) {
        console.log("Add varyings to shader for dataset ", setId);
        let nl = Array(5).join(" ");
        let newCode = "\n";
        let attributes = this.getAttributesOfSet(setId);
        for (let a = 0; a < attributes.length; a++) {
            let attribute = attributes[a];
            let type = attribute.type;
            if (type == "color") {
                type = "vec3";
            }
            newCode +=
                "varying " +
                type +
                " v" +
                this.capitalizeFirst(
                    this.cleanVarName(attribute.name)
                ) +
                ";\n";
        }

        shader = shader.replace("#genericVaryings#", newCode);
        return shader;
    }

    
    // Alters the shader source: add uniforms. Will also include color-related attributes, which are
    // needed for some color-related uniforms.
    addUniformsToShader(setId, setCount, shader) {
        let newCode = "\n";
        for (let i = 0; i < this.customUniforms.length; i++) {
            if (this.customUniforms[i].dataset !== setId) continue;

            let type = this.customUniforms[i].type;
            if (type == "color") {
                type = "vec3";
            }

            // The following is actually not yet supported in WebGL...
            let arrayExt = "";
            if (this.customUniforms[i].num > 1) {
                arrayExt = "[" + this.customUniforms[i].num + "]";
            }
            newCode +=
                "uniform " +
                type +
                " " +
                this.cleanVarName(this.customUniforms[i].name) +
                arrayExt +
                ";\n";
        }

        shader = shader.replace(
            "#colorDefinition#",
            this.createAttributeForShader(
                "colors",
                "vec3",
                "vSetId",
                setCount,
                false,
                false,
                false,
                false,
                4,
                true
            )
        );
        shader = shader.replace("#genericUniforms#", newCode);

        return shader;
    }

    
    // Creates the source code for a shader. Especially it allows interpolation, if we have multiple states
    // of a dataset. Optionally, we can pass it as varying
    // E.g. if we have a dataset with 3 states, then the attribute "position" will result in:
    // - the three states, i.e. position1, position2, position3 (attributes)
    // - positionOut, which is placed inside the shader function. The value is interpolated from position1,
    //   position2, position3, according to the current user-selected state
    // - optionally, a pass to vPosition (however, it assumes this varying was created elsewhere!)
    createAttributeForShader(
        attName,
        attType,
        dependency,
        count,
        shared,
        interpolate,
        normalize,
        addVarying,
        indent,
        defineTypes
    ) {
        let nl = "\n" + Array(indent + 1).join(" ");
        let code = nl;
        if (shared) {
            code +=
                (defineTypes ? attType + " " : "") +
                attName +
                "Out = " +
                attName +
                ";\n";
        } else if (count == 1) {
            code +=
                (defineTypes ? attType + " " : "") +
                attName +
                "Out = " +
                attName +
                "0;\n";
        } else {
            code +=
                (defineTypes ? "int " : "") +
                attName +
                "Index = int(" +
                dependency +
                ");" +
                nl;
            code +=
                (defineTypes ? "float " : "") +
                attName +
                "Fade = " +
                dependency +
                " - float(" +
                attName +
                "Index);" +
                nl;
            code += (defineTypes ? attType + " " : "") + attName + "Out;" + nl;
            for (let i = 0; i < count; i++) {
                if (interpolate && i >= 1) {
                    code +=
                        "if(" +
                        dependency +
                        " < float(" +
                        i +
                        "))  {" +
                        attName +
                        "Out = (1. - " +
                        attName +
                        "Fade) * " +
                        attName +
                        (i - 1) +
                        " + " +
                        attName +
                        "Fade * " +
                        attName +
                        i +
                        ";} " +
                        nl +
                        " else  ";
                    if (i == count - 1) {
                        code +=
                            "{" + attName + "Out = " + attName + i + ";}" + nl;
                    }
                } else if (!interpolate) {
                    code +=
                        "if(int(" +
                        dependency +
                        ") == " +
                        i +
                        ")  {" +
                        attName +
                        "Out = " +
                        attName +
                        i +
                        ";}" +
                        nl;
                }
            }
        }

        // Every attribute is finally forwarded to the fragment shader
        if (addVarying)
            code +=
                "v" +
                this.capitalizeFirst(attName) +
                " = " +
                attName +
                "Out;" +
                nl;
        return code;
    }

    // Alters the shader source: adds a (remove-)filter based on each attribute ("discard if not in user-specified range").
    addFilterToShader(setId, shader, indent) {
        console.log("Add filter to shader for dataset:", setId);
        let nl = "\n" + Array(indent + 1).join(" ");
        let newCode = nl;
        let attributes = this.getAttributesOfSet(setId);
        for (let a = 0; a < attributes.length; a++) {
            let attribute = attributes[a];
            console.log(
                "Add ",
                attribute.name,
                " to dataset ",
                attribute.dataset
            );

            let name = this.cleanVarName(attribute.name);
            if (attribute.dim == 1) {
                newCode +=
                    "if(v" +
                    this.capitalizeFirst(name) +
                    " < " +
                    name +
                    "From" +
                    " || v" +
                    this.capitalizeFirst(name) +
                    " > " +
                    name +
                    "To" +
                    ") {hideBecauseFilter = 1.;} " +
                    nl;
            }
        }

        shader = shader.replace("#attributeFilter#", newCode);
        return shader;
    }

    createFragmentShader(setId, setCount) {
        return this.addVaryingsToShader(
            setId,
            this.addFilterToShader(
                setId,
                this.addOpacityModesToShader(
                    setId,
                    this.addColorModesToShader(
                        setId,
                        this.addUniformsToShader(
                            setId,
                            setCount,
                            this.fragmentShader()
                        )
                    )
                ),
                4
            )
        )
    }

    createVertexShaderLine(setId, setCount) {
        return this.addVaryingsToShader(
            setId,
            this.addCustomAttributesToShader(
                setId,
                this.addMercatorModesToShader(
                    setId,
                    this.addUniformsToShader(
                        setId,
                        setCount,
                        this.vertexShaderLine()
                    )
                )
            )
        )
    }
    
    createVertexShaderTriangle(setId, setCount) {
        return this.addVaryingsToShader(
            setId,
            this.addCustomAttributesToShader(
                setId,
                this.addMercatorModesToShader(
                    setId,
                    this.addUniformsToShader(
                        setId,
                        setCount,
                        this.vertexShaderLine()
                    )
                )
            )
        )
    }
    
    /**
     * Raw vertex shader with placeholders
     */
    vertexShader() {
        return `
#genericUniforms#
#genericVaryings#
#genericAttributes#
#customVars#

attribute float setId;
attribute float axeType;
attribute float drawIndex;

varying vec3 vOrientation;
varying vec3 vOrientationColor;
varying vec3 vPosition;
varying vec3 vNextPosition;
varying vec3 vNormal;
varying vec3 vView;
varying vec3 vCenter;
varying float vDepth;
varying float vSetId;
varying float vAxeType;
varying float vDrawIndex;
varying float vDiscardThis;
varying float vHideThis;
varying float vLongDiff;
varying float vLatDiff;
uniform float scale;
uniform float state;
uniform float defocusState;
uniform float shading;
uniform float glossiness;
uniform float darkenInside;
uniform float mercator;
uniform int mercatorMode;
uniform float mercatorRadius;
uniform float mercatorOffset;
uniform float mercatorOffset2;
uniform float mercatorOffset3;
uniform float zLower;
uniform float zUpper;
uniform float xLower;
uniform float xUpper;
uniform float yLower;
uniform float yUpper;
uniform vec3 projPlane;
uniform vec3 projPlaneN;
uniform float projLevel;

mat4 rotationMatrix(vec3 axis, float angle) 
{
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;
    
    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                0.0,                                0.0,                                0.0,                                1.0);
}

void main() 
{
    vSetId = setId;
    vAxeType = axeType;
    vDrawIndex = drawIndex;
    // Define the state (for selected data), then calculate a position
    float stateInternal = drawIndex >= 0. ? state : defocusState;
    #genericAttributeInterpolation#

    // Now some checks whether this item is selected or not
    vDiscardThis = 0.;
    vHideThis = 0.;
    if(positionOut.z < zLower || positionOut.z > zUpper || 
        positionOut.x < xLower || positionOut.x > xUpper || 
        positionOut.y < yLower || positionOut.y > yUpper )
    {
        vHideThis = 1.;
    }

    vec3 projPlaneNn = normalize(projPlaneN);
    vec3 planeTest = positionOut.xyz - projPlane;
    bool isAbovePlane = dot(planeTest, projPlaneNn) >= 0.;
    if(isAbovePlane)
    {
        vHideThis = 1.;
    }

    // In case this element is hidden, change the state accordingly and 
    // re-assign all elements that depend on the state
    if(vHideThis > 0.5)
    {
        stateInternal = defocusState;
    #genericAttributeInterpolation#
    }
    

    if(!isAbovePlane && projLevel > 0.001)
    {
        float dist = length(planeTest) * dot(normalize(planeTest), projPlaneNn);
        positionOut.xyz -= projPlaneNn * dist * projLevel;
        
        planeTest = nextPositionOut.xyz - projPlane;
        dist = length(planeTest) * dot(normalize(planeTest), projPlaneNn);
        nextPositionOut.xyz -= projPlaneNn * dist * projLevel;
    }

    // Always determine lon and lat, since we might need it for coloring
    float r = length(positionOut.xyz);
    vec4 v = vec4(positionOut.xyz, 1.) * rotationMatrix(vec3(1,0,0), mercatorOffset)
        * rotationMatrix(vec3(0,1,0), mercatorOffset2)
        * rotationMatrix(vec3(0,0,1), mercatorOffset3);
        
    float rNext = length(nextPositionOut.xyz);
    vec4 vNext = vec4(nextPositionOut.xyz, 1.) * rotationMatrix(vec3(1,0,0), mercatorOffset)
        * rotationMatrix(vec3(0,1,0), mercatorOffset2)
        * rotationMatrix(vec3(0,0,1), mercatorOffset3);
        
    float lat = asin(v.z / r) ;  // z
    float lon = atan(v.x, v.y);  // y x
    float latNext = asin(vNext.z / rNext) ;  // z
    float lonNext = atan(vNext.x, vNext.y);  // y x
    vLongDiff = lonNext - lon; //lon > 0. ? lon - lonNext : lonNext - lon;
    vLatDiff = positionOut.y > 0. ? lat - latNext : latNext - lat;

    if(mercator > 0.002)
    {
        float mercatorHeight;
        #mercatorModes#

        if(abs(lon - lonNext) > 1.)
        {
            vDiscardThis = 1.;
        }

        vec3 posMercator = r / 3.142 * vec3(lon, log(tan(3.142 * 0.25 + lat * 0.5)), mercatorHeight * mercatorRadius - mercatorRadius/2.);
        vec3 nextPosMercator = r / 3.142 * vec3(lonNext, log(tan(3.142 * 0.25 + latNext * 0.5)), mercatorHeight * mercatorRadius - mercatorRadius/2.);
        positionOut = mix(positionOut, posMercator, mercator);
        nextPositionOut = mix(nextPositionOut, nextPosMercator, mercator);
    }
    vOrientation = normalize(nextPositionOut - positionOut);
    
    vec4 modelViewProjection = modelViewMatrix * vec4(positionOut, 1.0 );
    gl_Position = projectionMatrix * modelViewProjection;
    vPosition = gl_Position.xyz;
    vec4 modelViewProjectionNext = modelViewMatrix * vec4(nextPositionOut, 1.0 );
    vNextPosition = (projectionMatrix * modelViewProjectionNext).xyz;
    

    vDepth = clamp((-2.-modelViewProjection.z) / 2., 0., 1.);

    if(shading > 0.01)
    {
        // Assume camera is more distant, but just zoomed in. Leads to better shading,
        // as if coming from a very far light source, like the sun
        #customNormal#
    }

    if(darkenInside > 0.)
    {
        vCenter = (projectionMatrix * modelViewMatrix * vec4(0., 0., 0., 1.)).xyz;
    }
}`;
    }

    /**
     * Vertex shader with adaptions for lines
     */
    vertexShaderLine() {
        let vertexShaderLineVars = "";
        let vertexShaderLineNormal =
            "vView = normalize(vPosition - 1000. * cameraPosition);\n" +
            "vec3 biNormal = normalize(cross(vView, vOrientation));\n" +
            "vNormal = cross( biNormal, vOrientation );\n" +
            "vNormal *= sign( dot( vNormal, vec3( 0.0, 0.0, 1.0 ) ) );\n" +
            "vNormal *= sign( dot( vNormal, vView ) );\n" +
            "vNormal *= -1.;\n";
        return this.vertexShader()
            .replace("#customVars#", vertexShaderLineVars)
            .replace("#customNormal#", vertexShaderLineNormal);
    }

    /**
     * Vertex shader with adaptions for triangles
     */
    vertexShaderTriangle() {
        let vertexShaderTriangleVars = "attribute vec3 normalCustom;";
        let vertexShaderTriangleNormal =
            "vNormal = normalCustom;\n" +
            "vView = normalize(vPosition - 1000. * cameraPosition);\n";

        return this.vertexShader()
            .replace("#customVars#", vertexShaderTriangleVars)
            .replace("#customNormal#", vertexShaderTriangleNormal);
    }

    /**
     * Fragment shader, used for both line and triangle fragments
     */
    fragmentShader() {
        return `
#genericUniforms#
#genericVaryings#
uniform float alpha;
uniform int colorMode;
uniform int opacityMode;
varying vec3 vOrientation;
varying float vLongDiff;
varying float vLatDiff;
varying vec3 vPosition;
varying vec3 vNormal;
varying vec3 vView;
varying vec3 vCenter;
varying float vSetId;
varying float vAxeType;
varying float vDrawIndex;
varying float vDepth;
varying float vDiscardThis;
varying float vHideThis;
uniform vec3 diffuse;
uniform float opacity;
uniform float scale;
uniform vec3 primaryColor;
uniform vec3 secondaryColor;
uniform vec3 defocusColor;
uniform vec3 backgroundColor;
uniform float shading;
uniform float glossiness;
uniform float darkenInside;
uniform float defocusAlpha;
uniform float colorScale;
uniform sampler2D colorMap;
uniform int colorMapMode;
uniform float axesTransparancy;
uniform vec3 axesColor;


float lightIntensity2(vec3 viewDir, vec3 normalDir)
{
    float ambient = 0.2;
    float diffuse = 1.0;
    float specular = 7.0;
    float shininess = 250.;

    return ambient 
           + diffuse * abs(dot(-viewDir, normalDir)) //max(0., dot(-viewDir, normalDir)) 
           + specular *  pow(abs(dot(-viewDir, normalDir)), shininess);//pow(max(dot(-viewDir, normalDir), 0.0 ), shininess);
}
float lightIntensity(vec3 viewDir, vec3 normalDir)
{
    // diffuse term
    vec3 lightDir = -viewDir;
    float NdotL = dot(normalDir, lightDir);
    float diffuse = NdotL;
    float shininess = 50.;
    vec3 rVector = normalize(2.0 * normalDir * abs(dot(normalDir, lightDir)) - lightDir);
    float RdotV = dot(rVector, -viewDir);

    float specular = 0.;
    if(RdotV > 0.)
        specular = glossiness * pow(RdotV, shininess);
    return 0.2 + diffuse + specular;
}

vec3 pseudoRandomColor(float i) 
{
    return vec3(mod(7.  * i, 206.) + 50., 
                mod(11. * i, 128.) + 50., 
                mod(31. * i, 206.) + 20.) / 256.;
    float h = i * mod(2654435761., pow(2., 32.));
    return vec3(mod(h, 256.), mod(h, 10000.) / 40., mod(h, 65536.) / 256.) / 256.;
}

vec4 getColor(float value, float alpha)
{
    if(colorMapMode == 0) {
        return vec4(mix(primaryColor, secondaryColor, value), alpha);
    }
    else 
    {
        return texture2D(colorMap, vec2(value, 0.5));
    }
}

void main() 
{
    if(vAxeType > 0.5) {
        gl_FragColor = vec4(axesColor, axesTransparancy);
        if(vDiscardThis > 0.001) {
            discard;
        }
        return;
    }

    gl_FragColor = getColor(0., alpha);

    if(colorMode==1)
    {
        gl_FragColor = vec4(vOrientation.x / 2. + 0.5, vOrientation.y / 2. + 0.5, vOrientation.z / 2. + 0.5, alpha);
    }
    else if(colorMode == 2)
    {
        gl_FragColor.xyz = normalize(vec3(vLongDiff, 0, vLatDiff));
        gl_FragColor = vec4(gl_FragColor.x / 2. + 0.5, gl_FragColor.y / 2. + 0.5, gl_FragColor.z / 2. + 0.5, alpha);
    }
    else if(colorMode == 3)
    {
        gl_FragColor.xyz = vec3(clamp((vLatDiff) * colorScale, -1., 1.), 0,0);
        gl_FragColor = vec4(gl_FragColor.x / 2. + 0.5, gl_FragColor.y / 2. + 0.5, gl_FragColor.z / 2. + 0.5, alpha);
    }
    else if(colorMode == 4)
    {
        gl_FragColor.xyz = vec3(clamp(vLongDiff * colorScale, -1., 1.), 0,0);
        gl_FragColor = vec4(gl_FragColor.x / 2. + 0.5, gl_FragColor.y / 2. + 0.5, gl_FragColor.z / 2. + 0.5, alpha);
    }
    else if(colorMode == 5)
    {
        gl_FragColor.xyz = getColor(vDepth, 1.).xyz;
    }
    else if(colorMode == 6)
    {
        gl_FragColor.xyz = pseudoRandomColor(vDrawIndex);
    }
#colorModes#

    float sim = 1.0;
    if(shading > 0.01)
    {
        sim = mix(1.,  lightIntensity(vView, vNormal), shading);
    }

    float alphaScale = 1.;
    if(opacityMode==0)
    {
        // nothing to do
    }
    #adjustAlpha#
    gl_FragColor = vec4(clamp(sim * gl_FragColor.xyz, 0., 1.), alphaScale * alpha);


    if(darkenInside > 0.)
    {
        if(vCenter.z < vPosition.z)
        {
            //gl_FragColor.xyz = 1. - darkenInside;
            gl_FragColor.xyz = mix(gl_FragColor.xyz, backgroundColor, darkenInside);
        }
    }

    float hideBecauseFilter = 0.;
    #attributeFilter#

    // Painting something in defocus color (because it is hidden)
    if(vDrawIndex < 0. || vHideThis > 0.001 || hideBecauseFilter > 0.001)
    {
        gl_FragColor = vec4(clamp(sim * defocusColor, 0., 1.), defocusAlpha);
    }
    
    if(vDiscardThis > 0.001)
    {
        discard;
    }
}`;
    }
}
